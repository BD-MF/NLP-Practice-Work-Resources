@[toc]
# 数学基础
## 牛顿法和拟牛顿法有什么区别？
牛顿法需要直接求解hessian matrix（二阶梯度导函数）的逆，拟牛顿法用其他满足限制条件的矩阵来代替逆矩阵了

具体什么限制条件，怎么求解的，可以看[牛顿法、拟牛顿法](https://blog.csdn.net/sinat_41679123/article/details/107144355)

## 黑塞矩阵为什么要正定？
以二元函数举例，设`y = f(x)`，如果想求使得`f(x)`取最小值的x，函数的形状得是类似`x^2`的样子。

对于最小值点，有`f'(xm) = 0`，并且在`xm`之前，函数单调递减，在`xm`之后，函数单调递增。这就要求导函数在`xm`之前小于0，在`xm`之后大于0，即导函数是单调递增的。进一步要求二阶导函数大于0

推广到多元函数中，就是hessian matrix正定，也即特征值均大于0
## huber函数了解吗？和l1，l2比较起来优势是什么？【未回答】



# 数学概率类
## 已知有个 rand7() 的函数，返回 1 到 7 随机自然数，怎样利用这个 rand7() 构造 rand10()，随机 1 ~ 10
`rand7 - 1`可以得到等概率的0~6，`(rand7 - 1) * 7`可以等概率地得到`0, 7, 14, 21, 28, 35, 42`，然后再与`rand7`相加，因为`rand7`是等概率得到`1,2,3,4,5,6,7`，所以相加后就可以等概率得到`1~49`，去掉`41~49`9个数字，可以得到等概率的`1~40`共40个数字，按照4个一组做mapping，就可以得到`rand10`了

## 如何用一个均匀分布的随机变量，生成正态分布？
根据中心极限定理，任何服从均匀分布的随机变量，如果n足够大，则：
$$
\frac{\sum_i^n X_i - n\mu}{\sqrt{n} \sigma}
$$
都服从标准正态分布，即均值为0，方差为1的正态分布

## A和B比赛，A、B获胜的概率分别是0.6、0.4，如果你是A，3局2胜和5局3胜你会选择哪个？如果A和B比赛无数局，A获胜的概率是多少？
如果3局2胜，A获胜的情况是：胜胜、胜负胜、负胜胜，也即：
$$
P = 0.6 * 0.6 + 0.6 * 0.4 * 0.6 + 0.4 * 0.6 * 0.6 = 0.648
$$
如果5局3胜，A获胜的情况是：
1. A全胜：胜胜胜
2. A负1：胜胜负胜、胜负胜胜、负胜胜胜
3. A负2：A的最后一场肯定是胜的，从前面4场中挑2场负的，共有$C_4^2 = 6$种情况
$$\begin{aligned}
P &= 0.6 * 0.6 * 0.6 + 0.6 * 0.6 * 0.4 * 0.6 + 0.6 * 0.4 * 0.6 * 0.6 + 0.4 * 0.6 * 0.6 + C_4^2 * 0.6^3 * 0.4^2 \\
&= 0.68256
\end{aligned}$$

`0.68256 > 0.648`，所以从概率上来看，单局获胜率高的A，应该选5局3胜


如果比赛无数局，根据大数定律，A获胜场次的频率会趋近于概率0.6，也即A赢的场次会超过一半，所以A获胜的概率更大。

【题外话】
这个比赛A获胜的事件符合二项分布，根据中心极限定理，当p不变时，如果np无限大，则二项分布会趋于期望为$\mu = np, \sigma^2 = np(1 - p)$的正态分布。

二项分布：某一独立随机事件（例如打一局比赛）出现结果A（例如A胜一局）概率是p，那发生n次后出现A为k次（A在n局中胜了k局）的概率是$C_n^k p^k (1 - p)^{n - k}$

中心极限定理：在适当的条件下，大量相互独立随机变量的均值经适当标准化后依分布收敛于正态分布


## 在圆上任意取3个点，能够组成锐角三角形的概率？
首先，先看看怎样取点才能构成锐角三角形，在圆上任意取2个点A和B，画图如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200830221321742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxNjc5MTIz,size_16,color_FFFFFF,t_70#pic_center)
确定A点和B点后，剩下一个点C只有在A'B'对应的劣弧上才能保证是锐角三角形。

画辅助线的思路如下：
首先把A点和B点连起来，这是三角形的1条边，如果是锐角三角形，那么从A点做1条垂直AB的边（和圆相交于A'点），从B点做1条垂直AB的边（和圆相交于B'点），那么C点的选择只能在A'B'对应的劣弧上

直接求这条劣弧的长度不太好求，观察辅助线发现，其实A'点就是B点过圆心的直径的另一个端点（直径对应的角为90度），同理B'点就是A点过圆心的直径的端点，所以把两条直径画上

C点的选择受A点和B点两个点同时影响，
考虑A点影响：C点要在以A点为直径，把圆劈成2半的某一半上，也就是图中的蓝色半圆上：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200830222409665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxNjc5MTIz,size_16,color_FFFFFF,t_70#pic_center)
同理考虑B点影响，C点要在B的直径的半圆上，也就是下图中红色的半圆上：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200830222527930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxNjc5MTIz,size_16,color_FFFFFF,t_70#pic_center)
为了同时符合条件，C点要在上面红色、蓝色半圆的相交的弧线上，也即下图的紫色弧线上：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200830222654822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxNjc5MTIz,size_16,color_FFFFFF,t_70#pic_center)
求紫色弧的概率，就是：
$$
P = \frac{1}{2} * \frac{1}{2} = \frac{1}{4}
$$

## 43个石头，A,B轮流拿，每次可以拿1~3个，没有石头拿的人失败，A先拿能否保证自己获胜？
对于有n个石头的情况，假设每人能拿1～m个石头，则`n = m + 1`时，先拿的人必败。因为无论先拿的人拿走几个，后拿的人都可以把最后一个取走。
所以当`n = (m + 1) * r + k`时，先拿的人拿走`k`个，然后之后每次拿石头都保证和对方拿的石头个数之和是`m`的倍数，最后一个石头就肯定是被先拿的人拿走的。

对这道题来说，如果最后当A拿完后剩下`4`个石头，那么不管B拿几个，A都能获胜。所以A需要让剩下的石头永远是`4`的倍数，`43 % 4 = 3`，所以一开始A拿走3个石头即可。之后每次取石头，都保持和B拿走的数量之和是4即可。

## 1000盏灯开着，1000个人标号1~1000依次进入，每个人进去按一下自己标号倍数的开关，问最后哪些灯亮着？
一个灯被开关偶数次，则状态保持和初始一样不变，即亮着。

对于6号灯，标号为`1,2,3,6`的人会按它，发现其实就是6的因数，因为因数是成对出现的，所以肯定是偶数次。

对于4号灯，4的因数是`1,2,4`，因为`2`作为`4`的因数，有`2 * 2 = 4`，它的平方就是`4`，所以去掉重复的`2`，`4`的因数就变成奇数个了。因此实际上被按奇数次的灯，就是`1~1000`里面的完全平方数（一个数是另一个数的平方，这个数就被称为完全平方数）

最后亮着的灯就是`1~1000`中标号非完全平方数的那些灯

## 54张牌随机分3摞，两张王在同一摞的概率？
概率为：
$$
P = \frac{C_3^1 * C_{52}^{16} * C_{36}^{18} * C_{18}^{18}}{C_{54}^{18} * C_{36}^{18} * C_{18}^{18}} = \frac{17}{53}
$$

## 一根绳子分成3段能拼成三角形的概率？
假设绳子长度为L，则分成的3段线段为：`a, b, L - (a + b)`

对线段的约束是：
$$
\begin{cases}
0 < a < l \\
0 < b < l \\
0 < l - (a + b) < l \Leftrightarrow 0 < a + b < l
\end{cases}
$$

可行域是一个边长为`l`的直角三角形

如果能组成三角形，需要满足的条件是：任意两边之和大于第三边，就有：
$$\begin{aligned}
& \begin{cases}
a + b > l - (a + b) \\
a + l - (a + b) > b \\
b + l - (a + b) > a \\
\end{cases} \\
\Leftrightarrow 
& \begin{cases} 
a + b > \frac{l}{2} \\
b < \frac{l}{2} \\
a < \frac{l}{2}\\
\end{cases}
\end{aligned}$$

满足条件的区域是一个边长为`l / 2`的直角三角形

所以概率为：
$$
P = \frac{\frac{1}{2} * (\frac{1}{2}L)^2}{\frac{1}{2} L ^2} = \frac{1}{4}
$$


## 有1000瓶水，其中有1瓶水有毒，现有10只小白鼠，中毒反应在第七天显示出来，请问如何在第七天测试出哪一瓶水有毒
利用二进制的思想

1. 我们将1000瓶液体编号1-1000，然后将编号转化为10位二进制，如1号就是0000000001
2. 将十只小白鼠编号1-10
3. 将液体的二进制编号上为1的位数给对应的小白鼠喝，如液体编号为 1111100000，那就是1-5号小白鼠不喝这瓶液体，6-10号小白鼠喝这瓶液体
4. 一星期后观察小白鼠的死亡情况，如果1-5号小白鼠死亡，6-10号小白鼠存活，那么有毒的那瓶液体对应的二进制编码为 0000011111
5. 将第四步得到的二进制编码转化为十进制，这里是31号，因此我们可以推断出编号为31的液体是被污染的


## 已知a,b独立，满足均匀分布(0, 1)，求E(max(a, b))
a, b ~ U(0, 1)，均匀分布的概率密度函数为：$F(x) = \frac{x - a}{b - a}$

记X~max(a, b)，则：
$$\begin{aligned}
F(x) &= P(X \leq x) \\
&= P(a \leq x, b \leq x) \\
&= P(a \leq x)P(b \leq x) \\
&= \frac{x - 0}{1 - 0}  * \frac{x - 0}{1 - 0} \\
&= x^2
\end{aligned}$$
第二步到第三步能拆开，是因为a,b独立

$f(x) = F'(x) = 2x$

继续有：
$$\begin{aligned}
E(X) &= \int_{-\infty}^{\infty}xf(x) \; dx \\
&=\int_0^1x*2x \; dx \\
&= \frac{2}{3}x^3|_0^1 \\
&= \frac{2}{3}
\end{aligned}$$

## 已知X，Y相互独立，并且已知E(X), E(Y), var(X), var(Y), 求var(XY)
已知：
$$\begin{aligned}
Var(XY) &= E(X^2Y^2) - E^2(XY) \\
&= E(X^2)E(Y^2) - E^2(X)E^2(Y)
\end{aligned}$$

并且
$$\begin{aligned}
Var(X) &= E(X^2) - E^2(X) \\
\Leftrightarrow \; E(X^2) &= Var(X) + E^2(X) \\
\end{aligned}$$
同理$E(Y^2) = Var(Y) + E^2(Y)$

代入第一个式子，有：
$$\begin{aligned}
Var(XY) &= E(X^2)E(Y^2) - E^2(X)E^2(Y) \\
&= [Var(X) + E^2(X)] * [Var(Y) + E^2(Y)] - E^2(X)E^2(Y) \\
&= Var(X)Var(Y) + Var(X)E^2(Y) + E^2(X)Var(Y)
\end{aligned}$$


## 抛一个6面的骰子，连续抛直到6为止，问期望的抛的次数是多少
设期望次数为E，则E的状态有2个来源：抛出来了6，没有抛出来6
1. 1次抛出6的概率为1/6，那么期望次数为1*1/6
2. 本次抛出非6数字的概率为5/6，因为没有抛出6，因此期待抛出6还需要执行试验的次数仍为E，需要注意加上本次（1次）失效的抛掷，即期望次数为(1+E)(5/6)

综合可得：
$$
E = 1* \frac{1}{6} + (1+E) * \frac{5}{6}
$$

解得： E = 6
## 一个均匀的骰子，6个面被抛出来的概率都相同，如果想要每个面都被抛出来，抛的次数的期望是多少？
从上一题进一步推广而来。
设$E(i)$表示已经抛出`i`个不同面，为了满足条件，还需要抛的期望次数，则：
如果本次抛出来了重复的数字，期望次数为$\frac{i}{6} * (1 + E(i))$
如果本次抛出来了新数字，期望次数为$(1 - \frac{i}{6}) * (1 + E(i + 1))$

综上，$E(i) = E(i + 1) + \frac{6}{6 - i}$
E(6) = 0，意思是已经抛出6个面之后，不需要再抛了，所以期望抛的次数为0

要计算的是$E(0)$，有：
$$E(0) = \frac{6}{6 - 5} + \frac{6}{6 - 4} + \frac{6}{6 - 3} + \frac{6}{6 - 2} + \frac{6}{6 - 1} + \frac{6}{6 - 0} = 14.7$$

---
**另外一种做法**
首先，这个事件服从几何分布。因为对于第一次抛，抛出来什么都行。第二次抛时，需要抛出除了第一次抛出的面的其他面，所以该事件符合几何分布。

**几何分布**：前k-1次失败，第k次成功的概率
概率：
$$
P(X = k) = (1 - p)^{k - 1}p
$$
期望：$E(X) = \frac{1}{p}$
方差：$D(X) = \frac{1 - p}{p^2}$

第一次抛，抛出来想要的面的概率是$p_1 = \frac{6}{6} = 1$
第二次抛，抛出来想要的面的概率是$p_2 = \frac{5}{6}$
第三次，$p_3 = \frac{4}{6}$
所以，每个面都抛出来的期望是：
$$
E(X) = \sum_{i = 1}^6 \frac{1}{p_i} = \frac{6}{6} + \frac{6}{5} + \frac{6}{4} + \dots + \frac{6}{1} = 14.7(次)
$$

该问题的延伸问题，是[Coupon collector's problem](https://en.wikipedia.org/wiki/Coupon_collector's_problem)

##  一个木桶里面有M个白球，每分钟从桶中随机取出一个球涂成红色（无论白或红都涂红）再放回，问将桶中球全部涂红的期望时间是多少？
参考链接：[https://www.cnblogs.com/fanling999/p/6777335.html](https://www.cnblogs.com/fanling999/p/6777335.html)

将上面的题继续推广，令`E[i]`表示木桶里有`i`个红球时，还需要抽取多少时间可以将所有球都染成红色，对于当前状态下`E[i]`的计算可以分解为两个部分：
[1] 抽取到的是红球： 需要的时间期望为 `i/M * (1+E(i))`，其中`i/M`表示抽取红球的概率，因为抽取到的是红球因此状态没有改变，仍然是`E(i)`
[2] 抽取到的是白球： 需要的时间期望为 `(1-i/M) * (1+E(i+1))`，其中`(1-i/M)`表示抽取到白球的概率，因为抽取到了白球，被涂成红色以后，木桶里将会有`i+1`个红球，因此状态迁移到 `E(i+1)`，注意加上当前实验的时间 1
综合可得：
`E(i) = i/M *（1+E(i)） + (1-i/M) * (1+E(i+1))`
化简可得：
`E(i) = E(i+1) + M/(M-i)`
显然有： E(M) = 0， 当前桶里M个球都是红色的，不用再做任何抽取操作
（编程时依次从E(M)计算到E(0)，返回E(0)即可）

将递归式展开有：`E(0) = M/M + M/(M-1) + ... + M/1 + 0`
## 已知一随机发生器，产生0的概率是p，产生1的概率是1-p，现在要你构造一个发生器，使得它产生0和1的概率均为1/2
参考链接：[https://www.cnblogs.com/fanling999/p/6777335.html](https://www.cnblogs.com/fanling999/p/6777335.html)

由题目有：
0 : p
1 : 1-p

连续产生两个数，其组合以及概率如下：
00 : $p^2$
01 : $p*(1-p)$
10 : $(1-p)*p$
11 : $(1-p)^2$

可以发现 01 和 10 组合的概率是相等的，只需要将其分别映射到0和1即可。即每次随机产生两个数，如果组合为00或11则丢弃，若为01则映射到1，若为10则映射到0，这样一来产生0和1的概率均为 1/2 。

其余可参考：[https://www.cnblogs.com/fanling999/p/6777335.html](https://www.cnblogs.com/fanling999/p/6777335.html)

## 已知一对夫妻有2个孩子，其中之一是男孩，求另外一个是男孩的概率？
记X为2个孩子其中之一是男孩的概率，Y为另外一个是男孩的概率，需要求$P(Y|X)$
$$\begin{aligned}
P(Y|X) &= \frac{P(Y, X)}{P(X)} \\
&= \frac{\frac{1}{4}}{1 - \frac{1}{4}} \\
&= \frac{1}{3}
\end{aligned}$$
其中，
$P(Y, X)$表示其中一个是男孩，另外一个也是男孩，即2个孩子都是男孩的概率，1/4
$P(X)$是其中之一是男孩的概率，应该是用`1`减去全部是女孩的概率，即`1 - 1 / 4 = 3 / 4`

## 连续抛一枚公平的硬币，直到连续出现两次正面为止，平均要扔多少次硬币？
参考链接：[http://sofasofa.io/forum_main_post.php?postid=1001963](http://sofasofa.io/forum_main_post.php?postid=1001963)
假定扔出正面(H)的概率为p，扔出反面(T)的概率为1-p。

我们需要扔出连续2个H。在整个过程有这么几种状态：
1）当前连续0个正面（0H）；2）当前连续1个正面（1H）；当前连续2个正面（2H）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200831190512758.png#pic_center)
状态转换图如上。

如果当前是0H，那么p的概率，下一个状态是1H；1-p的概率维持在0H。

如果当前是1H，那么p的概率，下一个状态为2H（达到条件，任务完成）；1-p的概率回到0H。

假设期望x次后，得到2H。

那么
$x=(1−p)(1+x)+p^2×2+p(1−p)(2+x)$

第一个部分$(1−p)(1+x)$的意思是说，如果先扔出一个T，然后状态保持在0H，所以人仍然需要x次来完成任务。第二部分是说，先扔出H，再扔出H，两步完成任务，这种情况的概率为$p^2$。第三部分是先扔出一个H，此时状态为1H，然后又扔出一个T，状态回到0H，这种情况的概率为p(1−p)，用了两次回到0H，所以需要2+x次。

根据上面的式子，可以解得：$x=\frac{1+p}{p^2}$

这个硬币是无偏差的，所以p=0.5，所以x=6。
# 大数据处理类
## mapreduce中map的数量和reducer的数量和什么有关？
map数量和输入的文件个数有关，reducer数量是自己设置的，默认为1

## mapreduce工作流程？
1. map阶段：根据用户的map函数产生key, value对
2. shuffle：根据key进行shuffle，保证相同的key落在1个reducer上
3. reduce：执行reduce()函数
## spark为什么比mapreduce快？
1. 基于内存计算，减少低效的磁盘交互；
2. 高效的调度算法，基于DAG；
3. 容错机制Linage，精华部分就是DAG和Lingae

## spark的DAG工作流程？
1. 解释器是第一层。Spark 通过使用Scala解释器，来解释代码，并会对代码做一些修改。
2. 在Spark控制台中输入代码时，Spark会创建一个 operator graph， 来记录各个操作。
3. 当一个 RDD 的 Action 动作被调用时， Spark 就会把这个 operator graph 提交到 DAG scheduler 上。
4. DAG Scheduler 会把 operator graph 分为各个 stage。 一个 stage 包含基于输入数据分区的task。DAG scheduler 会把各个操作连接在一起。
5. 这些 Stage 将传递给 Task Scheduler。Task Scheduler 通过 cluster manager 启动任务。Stage 任务的依赖关系， task scheduler 是不知道的。
6. 在 slave 机器上的 Worker 们执行 task。

## spark的运行机制？
1. 构建Application的运行环境，Driver创建一个SparkContext
2. SparkContext向资源管理器（Standalone、Mesos、Yarn）申请Executor资源，资源管理器启动StandaloneExecutorbackend（Executor）
3. Executor向SparkContext申请Task
4. SparkContext将应用程序分发给Executor
5. SparkContext就建成DAG图，DAGScheduler将DAG图解析成Stage，每个Stage有多个task，形成taskset发送给task Scheduler，由task Scheduler将Task发送给Executor运行
6. Task在Executor上运行，运行完释放所有资源


## spark什么时候需要进行持久化？
1）某个步骤计算非常耗时，需要进行persist持久化

2）计算链条非常长，重新恢复要算很多步骤，因此这里最好使用persist

3）checkpoint所在的rdd要持久化persist。checkpoint前，要持久化，写个rdd.cache或者rdd.persist，将结果保存起来，再写checkpoint操作，这样执行起来会非常快，不需要重新计算rdd链条了。checkpoint之前一定会进行persist。

4）shuffle之后要persist，shuffle要进性网络传输，风险很大，数据丢失重来，恢复代价很大

5）shuffle之前进行persist，框架默认将数据持久化到磁盘，这个是框架自动做的。

# 计算机基础类
## python相关
### python中list的底层怎么实现？
`list`很像c/c++中的可变长度数组，由于长度可变，所以首先是有一个预分配的过程

申请`list`时，会预分配一定的内存空间。`list`数据结构包括表头的地址、列表总长、当前放了元素的长度。当`append`或`insert`等操作像`list`增加新元素时，会检查当前放了的元素是否到达列表总长的`1/2`，如果到达，则会调用`list_resize()`函数，来为列表再多申请一些内存。

`list_resize()`函数，作用是为列表申请内存，每次申请的长度会不断增加，以此避免重复调用`list_resize()`，列表的增长模式为：0，4，8，16，25，35，46，58，72，88……

如果当前的内存空间不够，使用`list_resize()`函数重新申请内存空间时，会直接将旧空间中的内容拷贝到新空间中。

### python处理多进程和多线程的底层原理
python中的多进程，用`multiprocess`模块。多线程，一般用`threading`模块。
假设CPU有4核，那么可以开启4个进程，如果有5个任务的话，会4个进程并行跑完4个后，再等其中1个跑完剩下的1个。

线程方面，python有GIL（全局解释器锁），保证同一时刻只有一个线程可以执行代码。

对于CPU密集型的程序，最好使用多进程
对于I/O密集型的程序，最好使用多线程。因为线程在等待的时候，会释放GIL

### 为什么python有GIL？
python对于内存管理，是采用了引用计数，因此需要用GIL

### python中浅拷贝和深拷贝
浅拷贝复制对象，对于对象中的元素，仍然使用元素的引用

深拷贝复制对象，对于对象中的元素，重新生成1份，而不是直接使用原先元素的引用

### python的生成器是什么
比如，如果需要创建一个包含100万个元素的列表，全部创建出来会很大，那么其实可以使用生成器，只有在迭代的时候才使用。

生成器表达式：
`print((x ** 2 for x in range(5)))`，和列表解析式差不多，区别在于把列表的`[]`换成`()`即可

生成器函数，就是函数中用`yield`而不用`return`，生成器函数返回一个可迭代对象，使用的时候最好用`for i in f(x)`来执行，不要使用`next(f(x))`，否则可能会报`StopIteration`错

## os
### 进程和线程的区别？【未回答】

